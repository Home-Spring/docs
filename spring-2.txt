(spring и его особености)
----------------------------------------------------------------------------------------------------------------[ http://habrahabr.ru/post/232381/ ]
(Евгений Борисов — Spring-потрошитель, часть 1) https://www.youtube.com/watch?v=BmBr5diz8WA&list=PLt7V06DPSFa0ZOGqm_QghnFkJwlDG5xyx&index=1
(Евгений Борисов — Spring-потрошитель, часть 2) https://www.youtube.com/watch?v=cou_qomYLNU&list=PLt7V06DPSFa0ZOGqm_QghnFkJwlDG5xyx&index=2
(Евгений Борисов — Spring 4.0: новое поколение) https://www.youtube.com/watch?v=hRtQFIVJ0ws&list=PLt7V06DPSFa0ZOGqm_QghnFkJwlDG5xyx&index=3
 ----------------------
(Евгений Борисов — Spring-потрошитель, часть 1) https://www.youtube.com/watch?v=BmBr5diz8WA
(Евгений Борисов — Spring-потрошитель, часть 2) https://www.youtube.com/watch?v=cou_qomYLNU
 ----------------------
(JUG UA: Евгений Борисов - "Spring 4") https://www.youtube.com/watch?v=yhQBgE-II2k
 (Евгений Борисов — Spring the Ripper) https://www.youtube.com/watch?v=ymNNbUi6L70
 - - - - - - - - - - -
(Урок 17 - Spring - Java для тестировщиков) https://www.youtube.com/watch?v=6mXTY7RSAf0
                        (Введение в Spring) https://www.youtube.com/watch?v=UcPSujRx9TI
(Build a Hello World REST service in less than 6 minutes) https://www.youtube.com/watch?v=47xNBNd-LLI
 - - - - - - - - - - -
(Евгений Борисов — eXtreme Application Platform (XAP)) https://www.youtube.com/watch?v=a-ArgBL5WhA
                   (Евгений Борисов — Power of Gradle) https://www.youtube.com/watch?v=NZJTYPLb0iE
 ---------------------------------------------
Жизненный цикл Spring-а:
1. "BeanDefinition Reader" ... (26.11.2003 - "XmlBeanDefinitionReader" - появилась возможность настраивать БИНЫ при помощи XML-а)
2. "ContextListener"
3. "BPP"
4. "Bean"
5. "BeanFactory"
6. "BFPP"
7. "ClassPathBeanDefinitionScanner"
26.11.2003 - "XmlBeanDefinitionReader" - появилась возможность настраивать контекст при помощи xml-а.
В xml-е прописываем бины, из этого xml-а подымаем контекст и против этого работаем.
Для того чтобы все это заработало нам нужен "BeanDefinition Reader" который является внутренним компонентом Spring-а,
который сканирует xml и все что мы там пишем переводит в BeanDefinition-ы.
"BeanDefinitions" это такой объект который хранит информацию про Bean-ы.
Как изначально декларировался "Bean" в Spring-е.
Для того чтобы настраивать БИН-ы через xml нам нужны СЕТЕРы.
С точки зрения xml-го спринга это не ПРОПЕРТИ.
Он попытается всеравно через РЕФЛЕКШИН вызвать СЕТЕР, а его нет и все упадет.
xml-файл выглядит так: открывается тег "beans", закрывается тег "beans", в нутри него прописываем БИНы ("bean").
Декларируем здесь наш БИН.
 ---------------------------------------------
1. Первым делом создаем свои класс(ы).
 Интерфейс - Quarter.
Class: имплементация - TerminatorQuarter.
 У него будет ПРОПЕРТИ ...
 (Для того чтобы наш класс(ы) мог работать как БИН у него должны быть определены СЕТЕРы для поля (ПРОПЕРТЯ))
2. Дальше необходимо задекларировать наш БИН при помощи xml-а ("context.xml").
 Указать через "property" наше значение.
3. (Подымаем контекст) "ClassPathXmlApplicationContext" - имплементация нашего Quarter сканируется и анализируется XmlBeanDefinitionReader-м.
 В качестве параметра передаем ему имя нашего xml-файла в котором задекларированы наши БИНы ("context.xml").
 ".getBean(...)" - Дальше можно вытащить из этого контекста БИН (по интерфейсу можно вытаскивать, а можно вытаскивать по классу)
 и сразу можно запустить его метод...
4. "BeanFactory" - центральный игрок спринга, который отвечает за создание и хранение всех объектов (которые Sigleton-ы).
 - Сначала мы пишем наши классы.
 - Декларируем наши БИНы из нашего класса(ов).
 - После этого когда мы подымаем контекст (при этом происходит следующее: приходит "BeanDefinition Reader", считывает с этого xml-а все
  декларации БИНов и кладет их в такой вот МАП (id-БИНа против его декларации) "BeanDefinitions")
  В "BeanDefinitions" собирается вся информация о нашем классе-БИНе: из какого класса его нужно создавать, есть ли у него инит-метод то как
  он называется, какие у него проперти...
5. После того как BeanDefinitions-ы были созданы "BeanFactory" начинает по ним работать, создает из наших классов объекты и все БИНы складывает
  в контейнер ("IoC Container").
  Здесь важно знать что если БИН является Singleton-м то по умолчанию он создается изначально как только подымается контекст (по умолчанию
  все Singleton-ы сразу создаются) и складываются в контейнер. А все ПРОТОТАЙПы создаются в момент когда они нужны (кто-то запросил ПРОТОТАЙП),
  в этот момент спринг его создал+настроил+отдал и забыл про него.
    Если мы прописываем например дестрой-метод для БИНа:
  - то для Singleton-а дестрой-метод работать будет (потому-что когда контекст закрывается спринг проходит по всем БИНам которые здесь
  хранятся, находит их дестрой-методы и их запускает, а ПРОТОТАЙП он нигде нехранит и соответствено для ПРОТОТАЙПа дестрой-метод никогда
  неработает)
  - ну и соответствено от сюда мы получаем уже полностью настроеные объекты.
6.1 "BPP" (BeanPostProcessor) - позволяет настраивать наши бины до того, как они попадают в этот контейнер ("IoC Container").
  Чтобы кастомизировать БИН и прикрутить к ниму свои аннотации (обучить спринг каким нибудь своим-собственным аннотациям).
  - существует 3-типа аннотации:
    1. "SOURCE" (данная аннотация видна исключительно в сорцах, когда мы компилируем в байткод уже ничего небудет... например: "@Override")
 2. "CLASS" (это рентейшин поле говорит что аннотация в байткод попасть должна но при этом всеравно через РЕФЛЕКШИН через рантайм мы ее
            считать не сможем, потому что ее там уже небудет - это по умолчанию)
 3. "RUNTIME" (это у большинства аннотаций,  которые видны в рантайме и которые через РЕФЛЕКШИН можно считать)
 У этого интерфейса ("BeanPostProcessor") 2-метода:
 1. "postProcessBeforeInitialization(..)" - вызывается до ИНИТ-метода
 2. "postProcessAfterInitialization(..)" - вызывается после ИНИТ-метода
 Здесь происходит следующее:
 - вначале мы создали класс-аннотацию с методами, которые будут являться параметрами... и принимать какие-то значения
 - потом эту аннотацию мы прописываем над полем (филд) для которого хотим ее применить(по сути, таким вот способом аннотация позволяет
  управлять процессом иннициализации всех полей перед этапом компиляции...сборки)
 - дальше нужно создать класс-имплементацию от BeanPostProcessor-а, собственно в теле которого и будут выполняться все эти предварительные
  операции...
 - и наконец этот класс-имплементацию от BeanPostProcessor-а нужно задекларировать в контексте спринга ("context.xml").
6.2 ДВУХ-ФАЗНЫЙ КОНСТРУКТОР в спринге:
 Сначала объект создается джавой, а спринг иннициализирует этот процесс.
 При помощи РЕФЛЕКШИНа спринг запустил его (класса) конструктор, конструктор отработал - объект создался. И когда объект создан спринг его
 уже может настраивать.
  Дело в том, что (наши) аннотации - это для BeanPostProcessor-а представляют собой такие же (равные) объекты как и все остальные.
 Поэтому изначально, за 1-проход, BeanPostProcessor все объекты изначально создает по отдельности. И объекты классов-аннотации тоже-самое (но
 поля там где присутствуют аннотации пока еще не может принять их, потому-что они пока еще не активны...).
 И только уже потом, за 2-проход, BeanPostProcessor, у которых присутствуют аннотации, активизирует-подключает их для тех полей где они
 присутствуют.
  Поэтому, если попытаться вывести значение поля в конструкторе для созданного объекта BeanPostProcessor-м - там будет
 нулевое-непроиннициализированное значение.
 - Существует и еще специальная аннотация спринга - "@PostConstruct", который обычно используется для повторной иннициализации объекта
  BeanPostProcessor-м (уже после создания объекта). И конечно же для того чтобы использовать такую аннотацию ее нужно задекларировать в
  контексте спринга ("context.xml").
  (использование "@PostConstruct" это гарантия того что наши аннотированые поля будут проинициализированы пост-контракт-ом... в БИН-ПОСТ-ПРОЦЕССОРе)
6.3 "init-method" в "BeanFactory":
 В первую очередь "BeanFactory" создаст те БИНы которые имплементируют "BeanPostProcessor" и с их помощью будет настраивать все остальные
 кастомерские БИНы (с бизнес-логикой).
 - Поэтому до "init-method", после того как объект создался и настроился в "BeanFactory", объект прошел первую стадию настройки
  BeanPostProcessor-ми ("postProcessBeforeInitialization(..)").
 - После этого вызвался "init-method" у данного БИНа, то есть, пост-контракт ("@PostConstruct") его отработал.
 - И потом, после "init-method", идет еще один проход ("postProcessAfterInitialization(..)").
 = и в конце уже получаем полностью настроеные объекты при помощы БИН-ПОСТ-ПРОЦЕССОРОВ.
7. Профилирование:
 Если тестирование мы используем на этапе разработки приложения и его классов (например: JUnit-тесты...).
 Профилирование - это логирование... (конечно-же каждый раз при обращении к методам нашего класса, немалую часть времени процессор будет
 тратить для лотрования действия... из-за этого наше приложение будет работать медленее). Поэтому профилирование мы можем включать только в
 случае при необходимости (когда нужно обнаружить истинную причину...).
 - Мы будет дописывать свою логику в объект (его методов) для логирования...
 Как добавить логику в уже существующий объект - в джаве нужно будет на лету сгенерировать новый класс - (другими словами) нужно подменить
 оригинальный объект.
 Поэтому новый класс который сгенериться на лету есть 2-варианта (это совершенно 2-разных подхода, через "JMX-console" - стандартизованные
  средства предоставления интерфейса управления с возможностью удаленного доступа...):
 1. "Dynamic Proxy" (статический метод генерирует классы на лету "Proxy.newProxyInstance(..)") - либо он должен имплементировать те-же самые
    интерфейсы (точно также и работают АСПЕКТы... в спринг-АОП);
 2. "CGLIB" - либо он должен наследоваться от оригинального класса и переопределять его методы (сделегировать метод - добавляя туда нужную
    логику - такой подход считается хуже: потому-что он и по ПЕРФОРМерсу обет, и дело в  различных ограничениях, например, не все можно
 наследовать "finally-классы-методы"... причем CGLIB раньше нужно было добавлять как отдельный jar-проект... в версии спринга-3.2 CGLIB
 упакован вместе);
(+) "MBean" и компоненты - состоит из MBean-сервера и MBean-клиента, которые позволяют на лету управлять через интерфейсы зарегистрированными
    MBean-компонентами. (это довольно старая технология и удобна когда нужно держать единственный-общий ресурс к которому будет открытый
 удаленный доступ из других мест..., что-то накштаут синхронизации для много-процессорных приложений)
  Для регистрации такого JMX-компонента нужно просто создать класс-интерфейс и в конце его имени добавить "MBean".
(+) ".invoke(..)" - это ссылка на оригинальный метод (если, например, мы его вызываем в классе-наследнике) с возможностью передать ему
    параметры.
(+) "(MBeanServer) ManagementFactory.getPlatformMBeanServer()", ".registerMBean(..)".
 Регистрировать можно в конструкторе нашего класса-имплементирующего "BeanPostProcessor", но важно чтобы он бросал "throws Exception"-исключения
 (на случай если такая регистрация уже существует и другие возможные ошибки...).
 - MBean это достаточно удобная вещь, она позволяет после запуска приложения и даже неостанавливая его, можно в горячем режиме, например,
  через "jvisualvm" (или другой удаленный инструмент... "jconsole") изменить значение для этого зарегистрированного MBean-компонента - и этим
  самым получать логирование.
8.1 ТРЕХ-ФАЗНЫЙ КОНСТРУКТОР в спринге:
 "ContextListener" - может слушать контекст спринга ("context.xml"), все ИВЕНТы которые с ним происходят (а с ним могут происходить разные
 неприятности):
 - "ContextStartedEvent" (это значит что контекст начал свое построение)
 - "ContextStoppedEvent"
 = "ContextRefreshedEvent" (когда он заканчивает свое построение он всегда делает РЕФРЕШ)
 - "ContextClosedEvent"
 (а всех ИВЕТов есть - 5)
8.2 Например: сервис, который разогревает свой кеш...
 Идея трех-фазового конструктора в том (ну если на этапе двух-фазового конструктора мы получаем полностью настроеные объекты "@PostConstruct"
 ..., а профилирование работает уже после этапе двух-фазового конструктора postProcessAfterInitialization(..)) чтобы отработать  уже после
 того как объекты будут полностью настроены (ну например для того чтобы залезть в базу... - только там у нас есть доступ еще позже чем
 пост-констракт).
 - (Очень удобно здесь пользоваться дженериками, на этапе иннициализации, чтобы не писать все 5-типов ИВЕНТов)
 - можно из ИВЕНТа вытащить "(ApplicationContext) .getApplicationContext()"
 = Итоги:
 1. первый конструктор - джава
 2. второй конструктор - @PostConstruct (за который отвечает BeanPostProcrssor)
 3. третий конструктор - @AfterProxy (за который отвечает ContextListener)
8.3 BeanDefinishion отвечает за вызов оригинального класса, который существует до этапа прокси...
 Ну поскольку ИВЕНТы принимают участие на всем этапе формирования объекта, здесь мы можем взять оригинальный класс
 (в спринг ижекнуть спринг - это нормально...)
 ((Class.forName(..)) ".getMethods()" - работает аналогично invoke(..) но только уже для оригинального класса который не-прокси...)
9.1 "BFPP" (BeanFactoryPostProcessor) - позволяет настравить БИН-дифиншоны, до того, как создаются БИНы (они работают еще до того как БИНы
 созданы и они могут еще что-то подкрутить в БИН-дифиншонах, например: если нужно передать логин/пароль через context.xml, но при этом чтобы
 не указывать его жестко-харкодом...)
 - "postProcessBeanFactory(..)" можно повлиять на BeanFactory до того как он начнет работать и можно повлиять на BeanDefinition до того как
  BeanFactory из него начнет создавать свои БИНы.
  (@Deprecated — отмечает, что метод устарел. Вызывает предупреждение компиляции, если метод используется, ну например в случае когда уже
  у нас есть какая-нибудь альтернатива...)
10. "ClassPathBeanDefinitionScanner" - он ResourceLoaderAware (подгружает дополнительные ресурсы - создает дополнительные BeanDefinition-ы)
11 Итоги:
 - (1) Мы написали свои классы;
 - (2) Спортировался XML-контекст;
 - (3) Создались BeanDefinition-ы;
 - (4) Пришли BeanFactoryPostProcessor-ы и покрамсали BeanDefinition-ы;
 - (5) После этого создались BeanPostProcessor-ы;
 - (6) наконец пошел (обычный) процесс создания объектов BeanFactory;
 - (7) и все готовый объекты сидят у нас в контейнере ("IoC Container" - этот тот-же ХЕШ-МЕП);
 сканирует пакет и ищет все БИНы которые аннотированы аннотацией @Component или любоой другой аннотацией которая включает в себя компонент...
12.1 История:
 - Spring-1 работал с XML-ом...;
 - Spring-2 (с версии 2.5) подкрутил аннотации...;
 - Spring-3 в котором появилась возможность конфигурировать БИНы в джава-файле (удобно тем что можно писать кастомную логику для конфигурации,
  а в xml-файле такого сделать невозможно)...;
 - Spring-4 конфигурация на GROVY...;
12.2 Виды контекстов:
 - ClassPathXmlApplicationContext
 - FileSystemXmlApplicationContext
 - WebApplicationContext
 - AnnotationConfigApplicationContext
 - GenericGrovyApplicationContext
 - PropertyFileApplicationContext
----------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------[ https://www.youtube.com/watch?v=YN66kDMjnYM&list=PLNclrLF8MXOydbirv6nAf6KQkVij-LCRK ]
(Java spring framework: Введение в бины, IoC, Урок 1!) https://www.youtube.com/watch?v=YN66kDMjnYM&list=PLNclrLF8MXOydbirv6nAf6KQkVij-LCRK
(Java spring framework: Работа с бинами, атрибут ref, урок 2) https://www.youtube.com/watch?v=En2598nGUcA&index=2&list=PLNclrLF8MXOydbirv6nAf6KQkVij-LCRK
(Java spring framework: Начало работы spring mvc, урок 3) https://www.youtube.com/watch?v=xw4YS8c-PbE&index=3&list=PLNclrLF8MXOydbirv6nAf6KQkVij-LCRK
(Java spring framework: Spring MVC (Contoller), урок 4) https://www.youtube.com/watch?v=FYJBC4WloIg&index=4&list=PLNclrLF8MXOydbirv6nAf6KQkVij-LCRK
(Java spring framework: Локализация Spring MVC (UTF-8, ISO-8859-1) . Урок 5) https://www.youtube.com/watch?v=CEGdROEYZWo&list=PLNclrLF8MXOydbirv6nAf6KQkVij-LCRK&index=5
(Java spring framework: Spring MVC, работа с формами (HttpServletRequest), Урок 6) https://www.youtube.com/watch?v=nFu_rRkQq2I&index=6&list=PLNclrLF8MXOydbirv6nAf6KQkVij-LCRK
 ----------------------------------------------------
 ----------------------------------------------------
----------------------------------------------------------------------------------------------------------------
(Сергей Куксенко — Stream API, часть 2) https://www.youtube.com/watch?v=i0Jr2l3jrDA

(Spring Data – новый взгляд на persistence) http://jeeconf.com/archive/jeeconf-2013/materials/spring-data/
  (Отладка Java приложений для начинающих) https://www.youtube.com/watch?v=w9Im4aAhvXE&list=UUxBfkMDXforX3wh97yUX45A

----------------------------------------------------------------------------------------------------------------[ http://eddnet.org/?p=1580 ]
(Концепция использования операции JOIN в MySQL)
 ----------------------------------------------------
 "JOIN" это аналог оператора "WHERE" (но "JOIN" имеет больше функциональных возможностей и преимуществ).
Существует "INNER JOIN" (он же просто JOIN) и "OUTER JOIN" (он же FULL OUTER JOIN).
Объединение - это когда мы строим общую таблицу, а результаты здесь объединяются из нескольких таблиц. Если при выборке количество строк равно,
тогда получаем полностью заполненую таблицу, а инначе - мы будем видеть полу-пустые (незаполненые) строки.
Значение этих самых полу-пустых (незаполненых) строк равняется "NULL".
 Например, есть 2-таблицы, нужно выбрать все поля из этих таблиц значения которых равны:
- (INNER) "JOIN" в самом первом случае мы будем видеть только те строки, значения которых совпадают...
- (INNER) "LEFT JOIN" объединение с левой-таблицей, будем видеть все результаты из левой таблицы и только те строки из правой значения
          которых совпадают (а все пустые поля, значения которых несовпадают, из правой таблицы будут NULL)...
- (INNER) "RIGHT JOIN" объединение с правой-таблицей, будем видеть все результаты из правой таблицы и только те строки из левой значения
          которых совпадают (а все пустые поля, значения которых несовпадают, из левой таблицы будут NULL)...
- (OUTER) "LEFT JOIN IS NULL" при этом мы будем видить только те строки из левой таблицы значения которых НЕсовпадает (или равняется NULL)
          с правой таблицей.
- (OUTER) "RIGHT JOIN IS NULL" при этом мы будем видить только те строки из правой таблицы значения которых НЕсовпадает (или равняется NULL)
          с левой таблицей.
- "FULL OUTER JOIN" здесь мы выведем абсолютно все поля из всех таблиц, а строки значения которых несовпадают будут видны нам как NULL...
- (OUTER) "FULL OUTER JOIN IS NULL" при этом мы будем видить только те строки из правой и левой таблицы значения которых несовпадают
 ----------------------------------------------------
----------------------------------------------------------------------------------------------------------------
